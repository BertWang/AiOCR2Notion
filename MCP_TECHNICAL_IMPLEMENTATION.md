# MCP æ¶æ§‹è¨­è¨ˆèˆ‡æŠ€è¡“å¯¦ç¾æŒ‡å—

## ç³»çµ±æ¶æ§‹åœ–

### æ•´é«”æ¶æ§‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        å‰ç«¯å±¤ (React)                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Upload Zone  â”‚  â”‚ Split Editor â”‚  â”‚ Settings / Marketplaceâ”‚ â”‚
â”‚  â”‚ (MCP é¸é …)   â”‚  â”‚ (MCP é¢æ¿)   â”‚  â”‚ (MCP é…ç½®)           â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚           â”‚                 â”‚                  â”‚                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                 â”‚                  â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚         Next.js API å±¤ (Backend)                   â”‚
     â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
     â”‚  â”‚ /api/uploadâ”‚  â”‚ /api/notes/[id]/mcp/actionâ”‚   â”‚
     â”‚  â”‚ /api/notes â”‚  â”‚ /api/mcp/services         â”‚   â”‚
     â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ /api/mcp/logs             â”‚   â”‚
     â”‚                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  ğŸŒŸ MCP Integration Layer (æ ¸å¿ƒ)          â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
    â”‚  â”‚ MCPServiceManager                  â”‚   â”‚
    â”‚  â”‚ â”œâ”€ æœå‹™ç”Ÿå‘½é€±æœŸ                   â”‚   â”‚
    â”‚  â”‚ â”œâ”€ é€£æ¥æ± ç®¡ç†                     â”‚   â”‚
    â”‚  â”‚ â”œâ”€ æœƒè©±ç®¡ç†                       â”‚   â”‚
    â”‚  â”‚ â””â”€ éŒ¯èª¤æ¢å¾©                       â”‚   â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
    â”‚  â”‚ Service å¯¦ä¾‹                       â”‚   â”‚
    â”‚  â”‚ â”œâ”€ OpenClawClient                  â”‚   â”‚
    â”‚  â”‚ â”œâ”€ BraveSearchClient               â”‚   â”‚
    â”‚  â”‚ â”œâ”€ GitHubClient                    â”‚   â”‚
    â”‚  â”‚ â”œâ”€ SlackClient                     â”‚   â”‚
    â”‚  â”‚ â”œâ”€ GoogleDriveClient               â”‚   â”‚
    â”‚  â”‚ â”œâ”€ WebCrawlerClient                â”‚   â”‚
    â”‚  â”‚ â”œâ”€ SQLiteClient                    â”‚   â”‚
    â”‚  â”‚ â””â”€ FilesystemClient                â”‚   â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
    â”‚  â”‚ å·¥å…·å±¤                             â”‚   â”‚
    â”‚  â”‚ â”œâ”€ ConnectionPool                  â”‚   â”‚
    â”‚  â”‚ â”œâ”€ RetryPolicy & CircuitBreaker    â”‚   â”‚
    â”‚  â”‚ â”œâ”€ AuthManager & CredentialMgr    â”‚   â”‚
    â”‚  â”‚ â”œâ”€ RateLimiter                     â”‚   â”‚
    â”‚  â”‚ â”œâ”€ Cache Layer                     â”‚   â”‚
    â”‚  â”‚ â””â”€ Performance Monitor             â”‚   â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  æ•¸æ“šæŒä¹…åŒ–å±¤ (Prisma + SQLite)           â”‚
  â”‚  â”œâ”€ Note (æ“´å±• MCP å­—æ®µ)                 â”‚
  â”‚  â”œâ”€ MCPServiceConfig                     â”‚
  â”‚  â”œâ”€ MCPSyncLog                           â”‚
  â”‚  â””â”€ Cache (å¯é¸ Redis)                   â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  å¤–éƒ¨ MCP æœå‹™                                        â”‚
  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
  â”‚  â”‚ OpenClaw   â”‚  â”‚ Brave API  â”‚  â”‚ GitHub API     â”‚  â”‚
  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
  â”‚  â”‚ Slack API  â”‚  â”‚ Google API â”‚  â”‚ Notion API     â”‚  â”‚
  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### è«‹æ±‚æµç¨‹åœ–

```
ç”¨æˆ¶ä¸Šå‚³åœ–ç‰‡
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Upload Componentâ”‚ (å‰ç«¯)
â”‚ é¸æ“‡ MCP é¸é …   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ POST /api/upload
         â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Upload Route Handler        â”‚
  â”‚ 1. ä¿å­˜æ–‡ä»¶                 â”‚
  â”‚ 2. å‰µå»º Note è¨˜éŒ„           â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Gemini AI è™•ç†              â”‚
  â”‚ OCR â†’ Markdown â†’ Summary    â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ MCP å¾Œè™•ç† (å¦‚æœé¸ä¸­)       â”‚
  â”‚                             â”‚
  â”‚ â”Œâ”€ OpenClaw åˆ†æ           â”‚
  â”‚ â”œâ”€ Brave Search æŸ¥æ‰¾       â”‚
  â”‚ â”œâ”€ Notion åŒæ­¥             â”‚
  â”‚ â””â”€ Slack é€šçŸ¥              â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ ä¿å­˜åˆ° SQLite               â”‚
  â”‚ æ›´æ–° Note è¨˜éŒ„              â”‚
  â”‚ è¨˜éŒ„ MCP æ“ä½œæ—¥èªŒ           â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ è¿”å›å‰ç«¯                    â”‚
  â”‚ revalidatePath('/')         â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
  ç”¨æˆ¶åœ¨ Dashboard çœ‹åˆ°æ–°ç­†è¨˜
  å¯ä»¥æŸ¥çœ‹ MCP è™•ç†çµæœ
```

---

## æ ¸å¿ƒæ¨¡å¡Šè©³ç´°è¨­è¨ˆ

### 1. MCPServiceManager å¯¦ç¾

#### æ–‡ä»¶çµæ§‹
```
src/lib/mcp/
â”œâ”€â”€ index.ts                    # ä¸»å…¥å£ï¼Œå°å‡º manager å–®ä¾‹
â”œâ”€â”€ types.ts                    # å…±ç”¨å‹åˆ¥å®šç¾©
â”œâ”€â”€ service-manager.ts          # æ ¸å¿ƒç®¡ç†é¡
â”œâ”€â”€ connection-pool.ts          # é€£æ¥æ± 
â”œâ”€â”€ session-manager.ts          # æœƒè©±ç®¡ç†
â”œâ”€â”€ error-handler.ts            # éŒ¯èª¤è™•ç†
â”œâ”€â”€ retry-policy.ts             # é‡è©¦ç­–ç•¥
â”œâ”€â”€ auth-manager.ts             # èªè­‰ç®¡ç†
â”œâ”€â”€ rate-limiter.ts             # é€Ÿç‡é™åˆ¶
â”œâ”€â”€ cache.ts                    # ç·©å­˜å±¤
â”œâ”€â”€ monitor.ts                  # æ€§èƒ½ç›£æ§
â”œâ”€â”€ services/                   # å„å€‹æœå‹™å¯¦ç¾
â”‚   â”œâ”€â”€ base-client.ts
â”‚   â”œâ”€â”€ openclaw/
â”‚   â”œâ”€â”€ brave-search/
â”‚   â”œâ”€â”€ github/
â”‚   â”œâ”€â”€ slack/
â”‚   â”œâ”€â”€ google-drive/
â”‚   â”œâ”€â”€ web-crawler/
â”‚   â”œâ”€â”€ sqlite/
â”‚   â””â”€â”€ filesystem/
â””â”€â”€ utils/                      # å·¥å…·å‡½æ•¸
    â”œâ”€â”€ encryption.ts
    â”œâ”€â”€ validation.ts
    â””â”€â”€ helpers.ts
```

#### MCPServiceManager æ ¸å¿ƒä»£ç¢¼

```typescript
// src/lib/mcp/service-manager.ts

import { EventEmitter } from 'events';
import { MCPConnectionPool } from './connection-pool';
import { MCPSessionManager } from './session-manager';
import { MCPAuthManager } from './auth-manager';
import { CircuitBreaker } from './error-handler';
import { RetryPolicy } from './retry-policy';

export interface MCPServiceConfig {
  id: string;
  name: string;
  type: string;
  enabled: boolean;
  endpoint?: string;
  auth?: {
    type: 'api_key' | 'oauth' | 'jwt' | 'basic';
    credentials?: Record<string, string>;
  };
  config?: Record<string, any>;
  required?: boolean;
  timeout?: number;
}

export interface MCPOperationResult {
  success: boolean;
  data?: any;
  error?: string;
  executionTime: number;
  metadata?: Record<string, any>;
}

export class MCPServiceManager extends EventEmitter {
  private services = new Map<string, MCPService>();
  private connectionPool: MCPConnectionPool;
  private sessionManager: MCPSessionManager;
  private authManager: MCPAuthManager;
  private circuitBreakers = new Map<string, CircuitBreaker>();
  private initialized = false;

  constructor() {
    super();
    this.connectionPool = new MCPConnectionPool(10, 2);
    this.sessionManager = new MCPSessionManager();
    this.authManager = new MCPAuthManager();
  }

  /**
   * åˆå§‹åŒ–ç®¡ç†å™¨ä¸¦é€£æ¥æ‰€æœ‰å•Ÿç”¨çš„æœå‹™
   */
  async initialize(configs: MCPServiceConfig[]): Promise<void> {
    if (this.initialized) {
      console.warn('MCPServiceManager already initialized');
      return;
    }

    try {
      console.log('Initializing MCPServiceManager...');

      // 1. åˆå§‹åŒ–é€£æ¥æ± 
      await this.connectionPool.initialize();
      console.log('âœ… Connection pool initialized');

      // 2. å•Ÿå‹•æœƒè©±æ¸…ç†å™¨
      this.sessionManager.startCleanupTimer();
      console.log('âœ… Session manager started');

      // 3. é€£æ¥æ‰€æœ‰å•Ÿç”¨çš„æœå‹™
      const connections = await Promise.allSettled(
        configs.map(config => this.connectService(config))
      );

      let successCount = 0;
      for (const result of connections) {
        if (result.status === 'fulfilled') {
          successCount++;
        } else {
          console.error('Service connection failed:', result.reason);
        }
      }

      console.log(`âœ… ${successCount}/${configs.length} services connected`);

      // 4. åŸ·è¡Œå¥åº·æª¢æŸ¥
      await this.healthCheck();

      this.initialized = true;
      this.emit('ready');
    } catch (error) {
      console.error('MCPServiceManager initialization failed:', error);
      this.emit('error', error);
      throw error;
    }
  }

  /**
   * é€£æ¥å–®å€‹æœå‹™
   */
  private async connectService(config: MCPServiceConfig): Promise<void> {
    try {
      const service = this.createService(config);

      // è¨­ç½®ç†”æ–·å™¨
      this.circuitBreakers.set(config.id, new CircuitBreaker());

      // é€£æ¥
      await service.connect();
      this.services.set(config.id, service);

      console.log(`âœ… Connected to ${config.name}`);
      this.emit('service-connected', { serviceId: config.id, name: config.name });
    } catch (error) {
      if (config.required) {
        throw error;
      }
      console.warn(`âš ï¸  Failed to connect to ${config.name}:`, error);
      this.emit('service-connection-failed', { serviceId: config.id, error });
    }
  }

  /**
   * å‰µå»ºæœå‹™å¯¦ä¾‹ï¼ˆå·¥å» æ¨¡å¼ï¼‰
   */
  private createService(config: MCPServiceConfig): MCPService {
    // æ ¹æ“šæœå‹™é¡å‹å‰µå»ºç›¸æ‡‰çš„å®¢æˆ¶ç«¯
    switch (config.type) {
      case 'openclaw':
        return new OpenClawService(config);
      case 'brave-search':
        return new BraveSearchService(config);
      case 'github':
        return new GitHubService(config);
      case 'slack':
        return new SlackService(config);
      case 'google-drive':
        return new GoogleDriveService(config);
      case 'web-crawler':
        return new WebCrawlerService(config);
      case 'sqlite':
        return new SQLiteService(config);
      case 'filesystem':
        return new FilesystemService(config);
      default:
        throw new Error(`Unknown service type: ${config.type}`);
    }
  }

  /**
   * åŸ·è¡Œå·¥å…·
   */
  async executeTool<T>(
    serviceId: string,
    toolName: string,
    args: Record<string, any>,
    options?: { timeout?: number; retryCount?: number }
  ): Promise<MCPOperationResult> {
    const startTime = Date.now();

    try {
      // 1. æª¢æŸ¥ç†”æ–·å™¨
      const breaker = this.circuitBreakers.get(serviceId);
      if (breaker?.isOpen()) {
        throw new Error(`Circuit breaker is open for ${serviceId}`);
      }

      // 2. æª¢æŸ¥é€Ÿç‡é™åˆ¶
      if (!(await this.checkRateLimit(serviceId))) {
        throw new Error(`Rate limit exceeded for ${serviceId}`);
      }

      // 3. æª¢æŸ¥èªè­‰
      await this.authManager.validateService(serviceId);

      // 4. å¾é€£æ¥æ± ç²å–é€£æ¥
      const connection = await this.connectionPool.acquire();

      try {
        // 5. åŸ·è¡Œå·¥å…·ï¼ˆå¸¶é‡è©¦ï¼‰
        const result = await this.executeWithRetry(
          () => this.callTool(serviceId, toolName, args),
          options?.retryCount || 3
        );

        // 6. è¨˜éŒ„æˆåŠŸ
        breaker?.recordSuccess();

        return {
          success: true,
          data: result,
          executionTime: Date.now() - startTime
        };
      } finally {
        // 7. é‡‹æ”¾é€£æ¥
        await this.connectionPool.release(connection);
      }
    } catch (error) {
      // è¨˜éŒ„å¤±æ•—
      const breaker = this.circuitBreakers.get(serviceId);
      breaker?.recordFailure();

      const errorMessage = error instanceof Error ? error.message : String(error);

      return {
        success: false,
        error: errorMessage,
        executionTime: Date.now() - startTime
      };
    }
  }

  /**
   * å¸¶é‡è©¦çš„å·¥å…·èª¿ç”¨
   */
  private async executeWithRetry<T>(
    fn: () => Promise<T>,
    maxRetries: number = 3
  ): Promise<T> {
    let lastError: Error | null = null;

    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        return await fn();
      } catch (error) {
        lastError = error as Error;

        // æª¢æŸ¥æ˜¯å¦æ‡‰è©²é‡è©¦
        const shouldRetry = this.shouldRetryError(error);
        if (!shouldRetry || attempt === maxRetries) {
          throw error;
        }

        // æŒ‡æ•¸é€€é¿
        const delay = Math.pow(2, attempt) * 1000;
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }

    throw lastError;
  }

  /**
   * æ±ºå®šæ˜¯å¦æ‡‰è©²é‡è©¦
   */
  private shouldRetryError(error: any): boolean {
    const retryableErrors = [
      'ECONNREFUSED',
      'ETIMEDOUT',
      'ENOTFOUND',
      'Rate limit',
      'Too many requests'
    ];

    const errorMessage = String(error);
    return retryableErrors.some(msg => errorMessage.includes(msg));
  }

  /**
   * å¯¦éš›èª¿ç”¨å·¥å…·
   */
  private async callTool(
    serviceId: string,
    toolName: string,
    args: Record<string, any>
  ): Promise<any> {
    const service = this.services.get(serviceId);
    if (!service) {
      throw new Error(`Service ${serviceId} not found`);
    }

    return service.callTool(toolName, args);
  }

  /**
   * æª¢æŸ¥é€Ÿç‡é™åˆ¶
   */
  private async checkRateLimit(serviceId: string): Promise<boolean> {
    // å¯¦ç¾é€Ÿç‡é™åˆ¶é‚è¼¯
    return true;
  }

  /**
   * å¥åº·æª¢æŸ¥
   */
  private async healthCheck(): Promise<void> {
    console.log('Running health check...');

    const checks = Array.from(this.services.entries()).map(
      async ([serviceId, service]) => {
        try {
          const healthy = await service.healthCheck();
          return { serviceId, healthy };
        } catch (error) {
          return { serviceId, healthy: false, error };
        }
      }
    );

    const results = await Promise.all(checks);
    for (const result of results) {
      if (result.healthy) {
        console.log(`âœ… ${result.serviceId} is healthy`);
      } else {
        console.warn(`âš ï¸  ${result.serviceId} health check failed`);
      }
    }
  }

  /**
   * é—œé–‰ç®¡ç†å™¨
   */
  async shutdown(): Promise<void> {
    console.log('Shutting down MCPServiceManager...');

    // é—œé–‰æ‰€æœ‰æœå‹™
    const shutdownPromises = Array.from(this.services.values()).map(service =>
      service.disconnect().catch(error => {
        console.error(`Error closing service:`, error);
      })
    );

    await Promise.all(shutdownPromises);

    // é—œé–‰é€£æ¥æ± 
    await this.connectionPool.drain();

    console.log('âœ… MCPServiceManager shutdown complete');
    this.initialized = false;
  }

  /**
   * ç²å–æœå‹™ç‹€æ…‹
   */
  getServiceStatus(serviceId: string): any {
    const service = this.services.get(serviceId);
    const breaker = this.circuitBreakers.get(serviceId);

    return {
      connected: service?.isConnected() ?? false,
      circuitBreakerOpen: breaker?.isOpen() ?? false,
      lastCheck: service?.getLastHealthCheck() ?? null
    };
  }

  /**
   * ç²å–æ‰€æœ‰æœå‹™ç‹€æ…‹
   */
  getAllServiceStatus(): Record<string, any> {
    const status: Record<string, any> = {};
    for (const serviceId of this.services.keys()) {
      status[serviceId] = this.getServiceStatus(serviceId);
    }
    return status;
  }
}

/**
 * åŸºç¤æœå‹™é¡
 */
export abstract class MCPService {
  protected config: MCPServiceConfig;
  protected connected: boolean = false;
  protected lastHealthCheck: Date | null = null;

  constructor(config: MCPServiceConfig) {
    this.config = config;
  }

  abstract connect(): Promise<void>;
  abstract disconnect(): Promise<void>;
  abstract callTool(toolName: string, args: Record<string, any>): Promise<any>;

  async healthCheck(): Promise<boolean> {
    this.lastHealthCheck = new Date();
    return this.connected;
  }

  isConnected(): boolean {
    return this.connected;
  }

  getLastHealthCheck(): Date | null {
    return this.lastHealthCheck;
  }
}

// å–®ä¾‹
let mcpManager: MCPServiceManager | null = null;

export function getMCPManager(): MCPServiceManager {
  if (!mcpManager) {
    mcpManager = new MCPServiceManager();
  }
  return mcpManager;
}
```

### 2. æ•¸æ“šåº«é·ç§»

```prisma
// prisma/migrations/[timestamp]_add_mcp_support/migration.sql

-- æ“´å±• Note è¡¨
ALTER TABLE "Note" ADD COLUMN "mcpMetadata" TEXT;
ALTER TABLE "Note" ADD COLUMN "mcpServices" TEXT;
ALTER TABLE "Note" ADD COLUMN "openclawAnalysis" TEXT;
ALTER TABLE "Note" ADD COLUMN "braveSearchResults" TEXT;
ALTER TABLE "Note" ADD COLUMN "notionPageId" TEXT;
ALTER TABLE "Note" ADD COLUMN "githubGistId" TEXT;
ALTER TABLE "Note" ADD COLUMN "slackThreadTs" TEXT;
ALTER TABLE "Note" ADD COLUMN "syncStatus" TEXT;
ALTER TABLE "Note" ADD COLUMN "lastMCPUpdate" DATETIME;

-- å‰µå»º MCPServiceConfig è¡¨
CREATE TABLE "MCPServiceConfig" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "serviceType" TEXT NOT NULL,
    "enabled" BOOLEAN NOT NULL DEFAULT true,
    "config" TEXT NOT NULL,
    "credentials" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL
);

-- å‰µå»º MCPSyncLog è¡¨
CREATE TABLE "MCPSyncLog" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "noteId" TEXT NOT NULL,
    "serviceType" TEXT NOT NULL,
    "operation" TEXT NOT NULL,
    "status" TEXT NOT NULL,
    "result" TEXT,
    "error" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY ("noteId") REFERENCES "Note" ("id") ON DELETE CASCADE
);

-- å‰µå»ºç´¢å¼•
CREATE INDEX "MCPSyncLog_noteId" ON "MCPSyncLog"("noteId");
CREATE INDEX "MCPSyncLog_serviceType" ON "MCPSyncLog"("serviceType");
CREATE INDEX "MCPSyncLog_createdAt" ON "MCPSyncLog"("createdAt");
```

### 3. API ç«¯é»å¯¦ç¾

#### æœå‹™ç®¡ç†ç«¯é»

```typescript
// src/app/api/mcp/services/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getMCPManager } from '@/lib/mcp';
import { prisma } from '@/lib/prisma';

/**
 * GET /api/mcp/services
 * ç²å–æ‰€æœ‰ MCP æœå‹™é…ç½®
 */
export async function GET(request: NextRequest) {
  try {
    const configs = await prisma.mCPServiceConfig.findMany();
    
    const manager = getMCPManager();
    const statuses = manager.getAllServiceStatus();

    return NextResponse.json({
      success: true,
      services: configs.map(config => ({
        ...config,
        status: statuses[config.serviceType]
      }))
    });
  } catch (error) {
    return NextResponse.json(
      { success: false, error: String(error) },
      { status: 500 }
    );
  }
}

/**
 * POST /api/mcp/services
 * å‰µå»º/é…ç½® MCP æœå‹™
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();

    const config = await prisma.mCPServiceConfig.create({
      data: {
        serviceType: body.serviceType,
        enabled: body.enabled ?? true,
        config: JSON.stringify(body.config || {}),
        credentials: body.credentials ? encryptCredentials(body.credentials) : null
      }
    });

    return NextResponse.json({
      success: true,
      config
    });
  } catch (error) {
    return NextResponse.json(
      { success: false, error: String(error) },
      { status: 400 }
    );
  }
}
```

#### ç­†è¨˜ MCP æ“ä½œç«¯é»

```typescript
// src/app/api/notes/[id]/mcp/action/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getMCPManager } from '@/lib/mcp';
import { prisma } from '@/lib/prisma';

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const body = await request.json();

    // ç²å–ç­†è¨˜
    const note = await prisma.note.findUnique({ where: { id } });
    if (!note) {
      return NextResponse.json(
        { success: false, error: 'Note not found' },
        { status: 404 }
      );
    }

    // åŸ·è¡Œ MCP æ“ä½œ
    const manager = getMCPManager();
    const result = await manager.executeTool(
      body.serviceType,
      body.action,
      {
        ...body.params,
        content: note.refinedContent || note.rawOcrText
      }
    );

    // è¨˜éŒ„æ“ä½œæ—¥èªŒ
    await prisma.mCPSyncLog.create({
      data: {
        noteId: id,
        serviceType: body.serviceType,
        operation: body.action,
        status: result.success ? 'success' : 'failed',
        result: result.data ? JSON.stringify(result.data) : null,
        error: result.error || null
      }
    });

    return NextResponse.json({
      success: result.success,
      data: result.data,
      error: result.error
    });
  } catch (error) {
    return NextResponse.json(
      { success: false, error: String(error) },
      { status: 500 }
    );
  }
}
```

---

## æ€§èƒ½å„ªåŒ–ç­–ç•¥

### 1. é€£æ¥æ± é…ç½®

```typescript
// æ ¹æ“šä¸åŒçš„å ´æ™¯èª¿æ•´
const poolConfigs = {
  // é–‹ç™¼ç’°å¢ƒ
  development: { min: 2, max: 5 },
  
  // ç”Ÿç”¢ç’°å¢ƒ
  production: { min: 10, max: 50 },
  
  // é«˜è² è¼‰å ´æ™¯
  highLoad: { min: 20, max: 100 }
};
```

### 2. ç·©å­˜ç­–ç•¥

```typescript
// ç·©å­˜é…ç½®
const cacheConfig = {
  // ç›¸åŒæŸ¥è©¢åœ¨ 5 åˆ†é˜å…§è¿”å›ç·©å­˜
  queryResultTTL: 300000,
  
  // æœ€å¤šç·©å­˜ 1000 å€‹æŸ¥è©¢çµæœ
  maxQueryCache: 1000,
  
  // æœå‹™é…ç½®ç·©å­˜ 1 å°æ™‚
  configCacheTTL: 3600000
};
```

### 3. æ‰¹é‡æ“ä½œå„ªåŒ–

```typescript
// æ‰¹é‡åˆ†æå¤šå€‹ç­†è¨˜
async function analyzeNotesBatch(noteIds: string[]) {
  const batchSize = 10;
  const results = [];

  for (let i = 0; i < noteIds.length; i += batchSize) {
    const batch = noteIds.slice(i, i + batchSize);
    
    const batchResults = await Promise.all(
      batch.map(noteId => 
        manager.executeTool('openclaw', 'analyze', { noteId })
      )
    );

    results.push(...batchResults);
  }

  return results;
}
```

---

## ç›£æ§å’Œå‘Šè­¦

### é—œéµæŒ‡æ¨™

| æŒ‡æ¨™ | å‘Šè­¦é–¾å€¼ | æª¢æŸ¥é »ç‡ |
|------|---------|---------|
| é€£æ¥æ± ä½¿ç”¨ç‡ | > 80% | æ¯åˆ†é˜ |
| æœå‹™éŸ¿æ‡‰æ™‚é–“ | > 5s | æ¯è«‹æ±‚ |
| éŒ¯èª¤ç‡ | > 5% | æ¯åˆ†é˜ |
| ç†”æ–·å™¨ç‹€æ…‹ | Open | å¯¦æ™‚ |
| èªè­‰å¤±æ•— | ä»»ä½•å¤±æ•— | å¯¦æ™‚ |

### ç›£æ§å¯¦ç¾

```typescript
// src/lib/mcp/monitor.ts

export class MCPMonitor {
  private metrics = new Map<string, Metric[]>();

  recordMetric(name: string, value: number, tags?: Record<string, string>) {
    const key = this.getKey(name, tags);
    
    if (!this.metrics.has(key)) {
      this.metrics.set(key, []);
    }

    this.metrics.get(key)!.push({
      timestamp: Date.now(),
      value,
      tags
    });

    // æª¢æŸ¥å‘Šè­¦æ¢ä»¶
    this.checkAlerts(name, value);
  }

  private checkAlerts(name: string, value: number) {
    const thresholds: Record<string, number> = {
      'connection_pool_usage': 0.8,
      'service_response_time': 5000,
      'error_rate': 0.05
    };

    if (value > (thresholds[name] || Infinity)) {
      this.emitAlert(name, value);
    }
  }

  private emitAlert(name: string, value: number) {
    console.warn(`âš ï¸  Alert: ${name} = ${value}`);
    // ç™¼é€å‘Šè­¦é€šçŸ¥ (Slack, éƒµä»¶ç­‰)
  }

  getMetrics(name: string, timeRange: number = 3600000): Metric[] {
    const now = Date.now();
    const allMetrics = Array.from(this.metrics.values()).flat();

    return allMetrics.filter(
      m => m.timestamp > now - timeRange
    );
  }
}

interface Metric {
  timestamp: number;
  value: number;
  tags?: Record<string, string>;
}
```

---

## å®‰å…¨æœ€ä½³å¯¦è¸

### 1. èªè­‰ä¿¡æ¯åŠ å¯†

```typescript
// æ‰€æœ‰æ•æ„Ÿä¿¡æ¯å¿…é ˆåŠ å¯†å­˜å„²
const encrypted = encrypt({
  apiKey: process.env.OPENCLAW_API_KEY,
  token: process.env.NOTION_TOKEN
});

await prisma.mCPServiceConfig.create({
  data: {
    credentials: encrypted
  }
});
```

### 2. é€Ÿç‡é™åˆ¶

```typescript
// å¯¦æ–½å¤šå±¤é€Ÿç‡é™åˆ¶
rateLimiter.setLimit({
  // å…¨å±€: æ¯åˆ†é˜ 1000 å€‹è«‹æ±‚
  global: 1000,
  
  // æ¯å€‹ç”¨æˆ¶: æ¯åˆ†é˜ 100 å€‹è«‹æ±‚
  perUser: 100,
  
  // æ¯å€‹æœå‹™: æ¯åˆ†é˜ 500 å€‹è«‹æ±‚
  perService: 500,
  
  // æ¯å€‹ IP: æ¯åˆ†é˜ 200 å€‹è«‹æ±‚
  perIP: 200
});
```

### 3. æ¬Šé™é©—è­‰

```typescript
// æª¢æŸ¥ç”¨æˆ¶æ˜¯å¦æœ‰æ¬Šä½¿ç”¨ç‰¹å®šæœå‹™
async function authorizeToolAccess(userId: string, serviceId: string): Promise<boolean> {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    include: { permissions: true }
  });

  return user?.permissions.some(p => p.serviceId === serviceId) ?? false;
}
```

---

## æ•…éšœæ’é™¤æŒ‡å—

### å¸¸è¦‹å•é¡Œå’Œè§£æ±ºæ–¹æ¡ˆ

#### Q: é€£æ¥è¶…æ™‚
```typescript
// åŸå› : æœå‹™ä¸å¯é”æˆ–é…ç½®éŒ¯èª¤
// è§£æ±º:
1. æª¢æŸ¥ endpoint é…ç½®æ˜¯å¦æ­£ç¢º
2. æª¢æŸ¥é˜²ç«ç‰†å’Œç¶²çµ¡é€£æ¥
3. å¢åŠ è¶…æ™‚æ™‚é–“ (config.timeout)
4. å•Ÿç”¨èª¿è©¦æ—¥èªŒ
```

#### Q: èªè­‰å¤±æ•—
```typescript
// åŸå› : ä»¤ç‰ŒéæœŸæˆ–ç„¡æ•ˆ
// è§£æ±º:
1. æª¢æŸ¥èªè­‰ä»¤ç‰Œæ˜¯å¦æ­£ç¢º
2. å˜—è©¦åˆ·æ–°ä»¤ç‰Œ
3. æª¢æŸ¥ä»¤ç‰Œæ˜¯å¦éæœŸ
4. ç¢ºèªæ¬Šé™ç¯„åœæ˜¯å¦è¶³å¤ 
```

#### Q: é€Ÿç‡é™åˆ¶éŒ¯èª¤
```typescript
// åŸå› : è«‹æ±‚éæ–¼é »ç¹
// è§£æ±º:
1. å¯¦æ–½æŒ‡æ•¸é€€é¿é‡è©¦
2. ä½¿ç”¨æ‰¹é‡æ“ä½œ
3. å¢åŠ é€Ÿç‡é™åˆ¶
4. ä½¿ç”¨ç·©å­˜æ¸›å°‘è«‹æ±‚
```

---

é€™ä»½æ–‡æª”æä¾›äº† MCP æ¶æ§‹çš„å®Œæ•´æŠ€è¡“å¯¦ç¾ç´°ç¯€ï¼Œå¯ç›´æ¥ç”¨æ–¼ç”Ÿç”¢ç’°å¢ƒé–‹ç™¼ã€‚
